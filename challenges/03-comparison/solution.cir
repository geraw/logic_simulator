# Solution for the "Largest of Three" challenge.

# Macro Definitions (using only NAND as a primitive gate)
NOT(x)      := NAND(x, x)
AND(x,y)    := NOT(NAND(x, y))
OR(x,y)     := NAND(NOT(x), NOT(y))

# Multiplexer: selects 'a' if 'c' is 0, else selects 'b'.
MUX(a,b,c)  := OR(AND(a, NOT(c)), AND(b, c))

# 3-way multiplexer: if sel1=1 choose a, else if sel2=1 choose b, else choose c
MUX3(a,b,c,sel1,sel2) := MUX(c, MUX(b, a, sel1), OR(sel1, sel2))

# --- Comparison Logic ---
# Track which inputs are still in the running (initially all are candidates)
# Use delayed feedback to maintain state across time steps

# State variables: 1 means the input is still a candidate
active1 = D(s1, 1)
active2 = D(s2, 1)  
active3 = D(s3, 1)

# At each bit position, eliminate candidates that have 0 when others have 1
# max_bit = maximum bit value among all active candidates
max_bit = OR(OR(AND(X1, active1), AND(X2, active2)), AND(X3, active3))

# Update candidate status: stay active if you were active AND 
# (you have the max bit OR the max bit is 0)
s1 = AND(active1, OR(NOT(max_bit), X1))
s2 = AND(active2, OR(NOT(max_bit), X2))  
s3 = AND(active3, OR(NOT(max_bit), X3))

# Output: the maximum input among the three
Y = max_bit