<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Ladderboard</title>
  <style>
    /* Layout: make content fill viewport and distribute sections vertically */
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, Arial, sans-serif; padding: 16px; display: flex; flex-direction: column; gap: 8px; }
    h1 { margin: 0; }
    #status { color: #333; }
    /* The main content area should take remaining height and allow sections to share it */
    #content { display: flex; flex-direction: column; gap: 12px; flex: 1 1 auto; min-height: 0; overflow: hidden; }
    /* Each challenge section becomes a flex child and will share available height equally */
  .ladder-challenge-section { display: flex; flex-direction: column; gap: 8px; flex: 1 1 0; min-height: 0; padding: 6px; border: 1px solid #e6e6e6; border-radius: 6px; background: #fff; position: relative; }
  .resize-handle { height: 8px; cursor: ns-resize; background: linear-gradient(90deg, rgba(0,0,0,0.02), rgba(0,0,0,0.06), rgba(0,0,0,0.02)); border-radius: 4px; margin-top: 6px; }
  .resize-toggle { position: absolute; right: 8px; top: 6px; background: rgba(0,0,0,0.03); border: 1px solid rgba(0,0,0,0.06); border-radius: 4px; padding: 2px 6px; cursor: pointer; font-size: 12px; }
    .ladder-challenge-section h3 { margin: 0; font-size: 1rem; }
    /* Scroll wrapper that confines the table/list and provides an independent scrollbar */
    .table-wrap, .list-wrap { overflow: auto; flex: 1 1 auto; min-height: 0; }
    .ladder-list { padding-left: 20px; margin: 0; }
    .ladder-row { margin: 6px 0; display:flex; align-items:center; gap:10px }
    .medal { width:28px; height:28px; display:inline-block }
    .ladder-info { flex: 1 }
    pre.csv-preview { white-space: pre-wrap; background:#f6f6f6; padding:8px; border-radius:4px }
    table.raw-table { border-collapse: collapse; width: 100%; }
    table.raw-table th, table.raw-table td { border: 1px solid #ddd; padding: 6px 8px}
    table.raw-table th { text-align: left; width: 60px;}
    table.raw-table th.timestamp-col { width: 160px; }
    /* Narrow columns used for gate counts */
    .col-narrow { white-space: nowrap; }
    .col-d { min-width: 64px; max-width: 100px; text-align: right; }
    .col-nand { min-width: 64px; max-width: 100px; text-align: right; }
  </style>
</head>
<body>
  <h1>CSCML25 Circuit Challenges Ladderboard</h1>
  <div id="status">Loading...</div>
  <div style="display:flex;gap:12px;align-items:center">
    <label for="challenge-select">Show:</label>
    <select id="challenge-select" style="min-width:240px"></select>
    <button id="prev-btn" title="Previous">◀</button>
    <button id="next-btn" title="Next">▶</button>
  </div>
  <div id="content" style="margin-top:8px"></div>

  <script>
    function escapeHtml(value) {
      if (value === null || value === undefined) return '';
      return String(value).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }
    // Robust CSV parser (RFC4180-ish) that supports quoted fields with newlines and escaped quotes
    function parseCsvRows(csvText) {
      const rows = [];
      let cur = '';
      let inQuotes = false;
      let field = '';
      const pushField = (r) => { r.push(field); field = ''; };
      const pushRow = (r) => { rows.push(r.slice()); r.length = 0; };

      const row = [];
      for (let i = 0; i < csvText.length; i++) {
        const ch = csvText[i];
        const next = csvText[i+1];
        if (inQuotes) {
          if (ch === '"') {
            if (next === '"') {
              field += '"'; // escaped quote
              i++; // skip next
            } else {
              inQuotes = false; // end of quoted field
            }
          } else {
            field += ch;
          }
        } else {
          if (ch === '"') {
            inQuotes = true;
          } else if (ch === ',') {
            row.push(field);
            field = '';
          } else if (ch === '\r') {
            // ignore CR, handle on LF
          } else if (ch === '\n') {
            row.push(field);
            field = '';
            rows.push(row.slice());
            row.length = 0;
          } else {
            field += ch;
          }
        }
      }
      // push last field/row
      if (inQuotes) {
        // malformed CSV: unterminated quotes — but push as-is
      }
      if (field !== '' || row.length > 0) {
        row.push(field);
        rows.push(row.slice());
      }
      return rows;
    }

    function parseCsvToObjects(csvText) {
      const rows = parseCsvRows(csvText || '');
      if (!rows || rows.length === 0) return [];
      const headers = rows[0].map(h => (h || '').trim());
      const objs = [];
      for (let i = 1; i < rows.length; i++) {
        const cols = rows[i];
        const obj = {};
        for (let j = 0; j < headers.length; j++) {
          obj[headers[j]] = (cols[j] === undefined) ? '' : cols[j];
        }
        objs.push(obj);
      }
      return objs;
    }
    function medalSvg(type) {
      const colors = { gold: '#ffd700', silver: '#c0c0c0', bronze: '#cd7f32' };
      const color = colors[type] || '#999';
      return '<svg width="28" height="28" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><circle cx="12" cy="9" r="5" fill="'+color+'" stroke="#333" stroke-width="0.5" /><rect x="9" y="14" width="6" height="8" fill="'+color+'" /><path d="M6 4 L12 10 L18 4" stroke="#333" stroke-width="1" fill="none" /></svg>';
    }

    (async function(){
      try {
        const params = new URLSearchParams(window.location.search);
        const csvUrl = params.get('csv');
        const mode = (params.get('mode')||'grouped').toLowerCase();
        if (!csvUrl) throw new Error('csv query parameter required');
        document.getElementById('status').textContent = 'Fetching CSV...';
        const r = await fetch(csvUrl);
        if (!r.ok) throw new Error('Fetch failed: '+r.status+' '+r.statusText);
        const text = await r.text();
        const records = parseCsvToObjects(text||'');
        if (!records.length) {
          document.getElementById('status').textContent = 'No records found';
          document.getElementById('content').innerHTML = '<pre class="csv-preview">'+escapeHtml(text)+'</pre>';
          return;
        }
        document.getElementById('status').textContent = '';
        const norm = k => (k||'').replace(/[^a-zA-Z0-9_]/g,'').toLowerCase();
        const mapped = records.map(r=>{ const o={}; for(const k in r) o[norm(k)]=r[k]; return o; });
        if (mode === 'raw') {
          // Render one table per challenge (hide Circuit column). Use canonical challenge order when available.
          const content = document.getElementById('content');
          const headers = Object.keys(records[0]);
          const circuitIdx = headers.findIndex(h => /circuit/i.test(h));
          const challengeIdx = headers.findIndex(h => /challenge/i.test(h));

          // Decide visible header order: hide Challenge, put Submitter first (if present), then D gates, NAND gates, Email, Submission Time (timestamp), then others
          const headerLookup = {};
          headers.forEach(h => { headerLookup[h.toLowerCase().replace(/[^a-z0-9]/g,'')] = h; });
          const pickHeader = (re) => {
            for (const h of headers) if (re.test(h)) return h;
            return null;
          };
          const submitterHdr = pickHeader(/submitter|name/i);
          const dHdr = pickHeader(/d\s*gates|dgates|^d$/i);
          const nandHdr = pickHeader(/nand\s*gates|nandgates|^nand$/i);
          const tsHdr = pickHeader(/timestamp|time|date/i);

          const visible = [];
          if (submitterHdr) visible.push(submitterHdr);
          if (dHdr) visible.push(dHdr);
          if (nandHdr) visible.push(nandHdr);
          if (tsHdr) visible.push(tsHdr);
          // add remaining headers except circuit and challenge
          headers.forEach(h => {
            if (h === submitterHdr || h === dHdr || h === nandHdr || h === tsHdr) return;
            if (/circuit/i.test(h)) return;
            if (/challenge/i.test(h)) return; // hide challenge column
            if (/email/i.test(h)) return; // hide email column
            visible.push(h);
          });

          // Group records by challenge header value
          const groups = {};
          records.forEach(rw => {
            const ch = (challengeIdx >= 0) ? (rw[headers[challengeIdx]] || 'unknown') : 'unknown';
            if (!groups[ch]) groups[ch] = [];
            groups[ch].push(rw);
          });

          // Try to get canonical challenge list (prefer stable ordering)
          async function fetchChallengesListLocal() {
            const candidates = ['../../challenges/challenges.json','../challenges/challenges.json','challenges/challenges.json'];
            for (const p of candidates) {
              try {
                const r = await fetch(p);
                if (!r.ok) continue;
                const arr = await r.json();
                if (Array.isArray(arr) && arr.length) return arr;
              } catch (e) {
                // ignore
              }
            }
            return null;
          }

          const canonical = await fetchChallengesListLocal();
          const order = (canonical && canonical.length) ? canonical : Object.keys(groups).sort();

          // Helper to set content height to fill viewport minus header/status
          function adjustContentHeight() {
            try {
              const contentEl = document.getElementById('content');
              if (!contentEl) return;
              const rect = contentEl.getBoundingClientRect();
              const bottomPadding = 16; // keep a small gap from bottom
              const newH = Math.max(100, window.innerHeight - rect.top - bottomPadding);
              contentEl.style.height = newH + 'px';
            } catch (e) {
              // ignore
            }
          }

          // Render a table for each challenge in order but only show one at a time.
          content.innerHTML = '';
          const sections = {};
          order.forEach(chName => {
            const rows = groups[chName] || [];
            const section = document.createElement('div');
            section.className = 'ladder-challenge-section';
            section.dataset.challenge = chName;
            const h = document.createElement('h3'); h.textContent = chName; section.appendChild(h);
            // resize toggle
            const resizeToggle1 = document.createElement('button'); resizeToggle1.className = 'resize-toggle'; resizeToggle1.textContent = '⤢'; resizeToggle1.title = 'Toggle expand';
            resizeToggle1.addEventListener('click', ()=>{
              if (section.dataset.expanded === '1') { section.dataset.expanded = '0'; section.style.flex = ''; }
              else { section.dataset.expanded = '1'; section.style.flex = '3 1 0'; }
            });
            section.insertBefore(resizeToggle1, section.firstChild);
            // add resize toggle (expand/collapse) and resize handle
            const resizeToggle2 = document.createElement('button'); resizeToggle2.className = 'resize-toggle'; resizeToggle2.textContent = '⤢'; resizeToggle2.title = 'Toggle expand';
            resizeToggle2.addEventListener('click', ()=>{
              if (section.dataset.expanded === '1') { section.dataset.expanded = '0'; section.style.flex = ''; }
              else { section.dataset.expanded = '1'; section.style.flex = '3 1 0'; }
            });
            section.insertBefore(resizeToggle2, section.firstChild);
            if (rows.length === 0) {
              const empty = document.createElement('div'); empty.textContent = 'No submissions yet.'; empty.style.color = '#666'; section.appendChild(empty);
            } else {
              const tableWrap = document.createElement('div'); tableWrap.className = 'table-wrap';
              const table = document.createElement('table'); table.className = 'raw-table';
              const thead = document.createElement('thead'); const trh = document.createElement('tr');
              // Render headers in preferred visible order
              visible.forEach(hdr => {
                const th = document.createElement('th');
                // Rename timestamp header
                if (tsHdr && hdr === tsHdr) th.textContent = 'Submission Time';
                else th.textContent = hdr;
                // Add classes for styling narrow columns
                if (tsHdr && hdr === tsHdr) th.className = 'timestamp-col';
                if (dHdr && hdr === dHdr) th.classList.add('col-d', 'col-narrow');
                if (nandHdr && hdr === nandHdr) th.classList.add('col-nand', 'col-narrow');
                trh.appendChild(th);
              });
              thead.appendChild(trh); table.appendChild(thead);
              const tbody = document.createElement('tbody');
              rows.forEach(rw => {
                const tr = document.createElement('tr');
                // Render columns in visible order
                visible.forEach(hdr => {
                  const td = document.createElement('td');
                  td.textContent = rw[hdr] || '';
                  // mirror header classes for narrow columns
                  if (dHdr && hdr === dHdr) td.classList.add('col-d', 'col-narrow');
                  if (nandHdr && hdr === nandHdr) td.classList.add('col-nand', 'col-narrow');
                  if (tsHdr && hdr === tsHdr) td.classList.add('timestamp-col');
                  tr.appendChild(td);
                });
                tbody.appendChild(tr);
              });
              table.appendChild(tbody);
              tableWrap.appendChild(table);
              section.appendChild(tableWrap);
              // add a draggable resize handle at the bottom of the section
              const handle = document.createElement('div'); handle.className = 'resize-handle'; section.appendChild(handle);
              (function(){
                let startY=0, startH=0, dragging=false;
                function onDown(e){ e.preventDefault(); dragging=true; startY = e.touches ? e.touches[0].clientY : e.clientY; startH = section.getBoundingClientRect().height; document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp); document.addEventListener('touchmove', onMove, {passive:false}); document.addEventListener('touchend', onUp); }
                function onMove(e){ if(!dragging) return; e.preventDefault(); const clientY = e.touches ? e.touches[0].clientY : e.clientY; const dy = clientY - startY; const newH = Math.max(80, startH + dy); section.style.flex = '0 0 ' + newH + 'px'; }
                function onUp(){ dragging=false; document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); document.removeEventListener('touchmove', onMove); document.removeEventListener('touchend', onUp); }
                handle.addEventListener('mousedown', onDown); handle.addEventListener('touchstart', onDown, {passive:false});
              })();
            }
            // stash but do not append yet
            sections[chName] = section;
          });
          // populate selector and show first item
          const select = document.getElementById('challenge-select');
          Object.keys(sections).forEach(k => { const opt = document.createElement('option'); opt.value = k; opt.textContent = k; select.appendChild(opt); });
          let visibleKey = Object.keys(sections)[0];
          function showSection(key) {
            content.innerHTML = '';
            if (!sections[key]) return;
            content.appendChild(sections[key]);
            adjustContentHeight();
            document.getElementById('status').textContent = '';
          }
          select.addEventListener('change', (e)=>{ visibleKey = e.target.value; showSection(visibleKey); });
          document.getElementById('prev-btn').addEventListener('click', ()=>{
            const opts = Array.from(select.options).map(o=>o.value);
            const idx = Math.max(0, opts.indexOf(visibleKey));
            const ni = (idx - 1 + opts.length) % opts.length;
            select.value = opts[ni]; select.dispatchEvent(new Event('change'));
          });
          document.getElementById('next-btn').addEventListener('click', ()=>{
            const opts = Array.from(select.options).map(o=>o.value);
            const idx = Math.max(0, opts.indexOf(visibleKey));
            const ni = (idx + 1) % opts.length;
            select.value = opts[ni]; select.dispatchEvent(new Event('change'));
          });
          showSection(visibleKey);
          window.addEventListener('resize', adjustContentHeight);
          return;
        }
        // grouped mode — build groups per challenge
        const groups = {};
  mapped.forEach(rw=>{
   const ch = rw['challenge'] || 'unknown';
   if (!groups[ch]) groups[ch]=[];
   // normalized header names remove spaces, e.g. 'D gates' -> 'dgates'
   const dStr = (rw['dgates'] || rw['d'] || '');
   const nStr = (rw['nandgates'] || rw['nand'] || '');
   const d = parseInt(String(dStr).replace(/[^0-9]/g,''),10) || 0;
   const nand = parseInt(String(nStr).replace(/[^0-9]/g,''),10) || 0;
   const ts = new Date(rw['timestamp']||rw['time']||rw['date']||'');
   const tsIso = (ts && !isNaN(ts.getTime())) ? ts.toISOString() : '';
   // DO NOT include email in the public/grouped model (privacy)
   groups[ch].push({ submitter: rw['submitter']||rw['name']||'', d, nand, ts, tsIso });
  });

        const content = document.getElementById('content');

        // Create an array of group entries with their sorted lists and best-key for ordering sections
        const groupEntries = Object.keys(groups).map(ch => {
          const arr = groups[ch];
          // sort lexicographically by D, then NAND, then Timestamp (ISO string)
          arr.sort((a,b) => {
            const da = String(a.d || ''), db = String(b.d || '');
            if (da < db) return -1; if (da > db) return 1;
            const na = String(a.nand || ''), nb = String(b.nand || '');
            if (na < nb) return -1; if (na > nb) return 1;
            const ta = String(a.tsIso || ''), tb = String(b.tsIso || '');
            if (ta < tb) return -1; if (ta > tb) return 1;
            return 0;
          });
          const best = arr.length ? arr[0] : null;
          const bestKey = best ? [String(best.d), String(best.nand), String(best.tsIso || '')] : [''];
          return { ch, arr, bestKey };
        });

        // Sort the challenge sections by their best entry's key lexicographically
        groupEntries.sort((A,B) => {
          const ka = A.bestKey; const kb = B.bestKey;
          for (let i = 0; i < Math.max(ka.length, kb.length); i++) {
            const aVal = String(ka[i] || '');
            const bVal = String(kb[i] || '');
            if (aVal < bVal) return -1;
            if (aVal > bVal) return 1;
          }
          return A.ch.localeCompare(B.ch);
        });

        // Render each group's section. Prefer canonical challenge order from challenges/challenges.json
        async function fetchChallengesList() {
          const candidates = ['../../challenges/challenges.json','../challenges/challenges.json','challenges/challenges.json'];
          for (const p of candidates) {
            try {
              const r = await fetch(p);
              if (!r.ok) continue;
              const arr = await r.json();
              if (Array.isArray(arr) && arr.length) return arr;
            } catch (e) {
              // ignore and try next
            }
          }
          return null;
        }

        const canonicalChallenges = await fetchChallengesList();

        if (canonicalChallenges && canonicalChallenges.length) {
          // Render in canonical order; include empty sections when no submissions exist
          canonicalChallenges.forEach(chName => {
            const found = groupEntries.find(g => g.ch === chName);
            const arr = found ? found.arr : [];
            const section = document.createElement('div');
            section.className = 'ladder-challenge-section';
            const h = document.createElement('h3'); h.textContent = chName; section.appendChild(h);
            const listWrap = document.createElement('div'); listWrap.className='list-wrap';
            const ol = document.createElement('ol'); ol.className='ladder-list';
            if (arr.length === 0) {
              const empty = document.createElement('div'); empty.textContent = 'No submissions yet.'; empty.style.color='#666'; section.appendChild(empty);
            } else {
              arr.forEach((row, idx)=>{
                const li = document.createElement('li'); li.className='ladder-row';
                const medal = idx===0?medalSvg('gold'):(idx===1?medalSvg('silver'):(idx===2?medalSvg('bronze'):''));
                const medalSpan = document.createElement('span'); medalSpan.className='medal'; medalSpan.innerHTML = medal;
                const info = document.createElement('span'); info.className='ladder-info'; info.innerHTML = '<strong>'+escapeHtml(row.submitter||'(anonymous)')+'</strong> — D: '+escapeHtml(row.d||'')+', NAND: '+escapeHtml(row.nand||'')+' — '+escapeHtml(row.tsIso||'');
                li.appendChild(medalSpan); li.appendChild(info); ol.appendChild(li);
              });
            }
            listWrap.appendChild(ol);
            section.appendChild(listWrap);
            // add a resize handle
            const handle = document.createElement('div'); handle.className = 'resize-handle'; section.appendChild(handle);
            (function(){
              let startY=0, startH=0, dragging=false;
              function onDown(e){ e.preventDefault(); dragging=true; startY = e.touches ? e.touches[0].clientY : e.clientY; startH = section.getBoundingClientRect().height; document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp); document.addEventListener('touchmove', onMove, {passive:false}); document.addEventListener('touchend', onUp); }
              function onMove(e){ if(!dragging) return; e.preventDefault(); const clientY = e.touches ? e.touches[0].clientY : e.clientY; const dy = clientY - startY; const newH = Math.max(80, startH + dy); section.style.flex = '0 0 ' + newH + 'px'; }
              function onUp(){ dragging=false; document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); document.removeEventListener('touchmove', onMove); document.removeEventListener('touchend', onUp); }
              handle.addEventListener('mousedown', onDown); handle.addEventListener('touchstart', onDown, {passive:false});
            })();
            content.appendChild(section);
          });
          // ensure content fills viewport
          adjustContentHeight();
          window.addEventListener('resize', adjustContentHeight);
        } else {
          // Fallback: render whatever groups we discovered from the CSV
          groupEntries.forEach(({ch, arr}) => {
            const section = document.createElement('div');
            section.className = 'ladder-challenge-section';
            const h = document.createElement('h3'); h.textContent = ch; section.appendChild(h);
            // resize toggle
            const resizeToggle3 = document.createElement('button'); resizeToggle3.className = 'resize-toggle'; resizeToggle3.textContent = '⤢'; resizeToggle3.title = 'Toggle expand';
            resizeToggle3.addEventListener('click', ()=>{
              if (section.dataset.expanded === '1') { section.dataset.expanded = '0'; section.style.flex = ''; }
              else { section.dataset.expanded = '1'; section.style.flex = '3 1 0'; }
            });
            section.insertBefore(resizeToggle3, section.firstChild);
            const listWrap = document.createElement('div'); listWrap.className='list-wrap';
            const ol = document.createElement('ol'); ol.className='ladder-list';
            arr.forEach((row, idx)=>{
              const li = document.createElement('li'); li.className='ladder-row';
              const medal = idx===0?medalSvg('gold'):(idx===1?medalSvg('silver'):(idx===2?medalSvg('bronze'):''));
              const medalSpan = document.createElement('span'); medalSpan.className='medal'; medalSpan.innerHTML = medal;
              // Do not display the submitter's email publicly
              const info = document.createElement('span'); info.className='ladder-info'; info.innerHTML = '<strong>'+escapeHtml(row.submitter||'(anonymous)')+'</strong> — D: '+escapeHtml(row.d||'')+', NAND: '+escapeHtml(row.nand||'')+' — '+escapeHtml(row.tsIso||'');
              li.appendChild(medalSpan); li.appendChild(info); ol.appendChild(li);
            });
            listWrap.appendChild(ol);
            section.appendChild(listWrap);
            // add a resize handle
            const handle = document.createElement('div'); handle.className = 'resize-handle'; section.appendChild(handle);
            (function(){
              let startY=0, startH=0, dragging=false;
              function onDown(e){ e.preventDefault(); dragging=true; startY = e.touches ? e.touches[0].clientY : e.clientY; startH = section.getBoundingClientRect().height; document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp); document.addEventListener('touchmove', onMove, {passive:false}); document.addEventListener('touchend', onUp); }
              function onMove(e){ if(!dragging) return; e.preventDefault(); const clientY = e.touches ? e.touches[0].clientY : e.clientY; const dy = clientY - startY; const newH = Math.max(80, startH + dy); section.style.flex = '0 0 ' + newH + 'px'; }
              function onUp(){ dragging=false; document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); document.removeEventListener('touchmove', onMove); document.removeEventListener('touchend', onUp); }
              handle.addEventListener('mousedown', onDown); handle.addEventListener('touchstart', onDown, {passive:false});
            })();
            content.appendChild(section);
          });
          // ensure content fills viewport
          adjustContentHeight();
          window.addEventListener('resize', adjustContentHeight);
        }
      } catch (err) {
        document.getElementById('status').textContent = 'Error: '+(err && err.message?err.message:err);
        console.error(err);
      }
    })();
  </script>
</body>
</html>