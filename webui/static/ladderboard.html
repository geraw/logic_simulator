<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Ladderboard</title>
  <style>
    /* Layout: make content fill viewport and distribute sections vertically */
    html, body { height: 100%; margin: 0; }
    body { font-family: system-ui, Arial, sans-serif; padding: 16px; display: flex; flex-direction: column; gap: 8px; }
    h1 { margin: 0; }
    #status { color: #333; }
    /* The main content area should take remaining height and allow sections to share it */
    #content { display: flex; flex-direction: column; gap: 12px; flex: 1 1 auto; min-height: 0; overflow: hidden; }
    /* Each challenge section becomes a flex child and will share available height equally */
    .ladder-challenge-section { display: flex; flex-direction: column; gap: 8px; flex: 1 1 0; min-height: 0; padding: 6px; border: 1px solid #e6e6e6; border-radius: 6px; background: #fff; }
    .ladder-challenge-section h3 { margin: 0; font-size: 1rem; }
    /* Scroll wrapper that confines the table/list and provides an independent scrollbar */
    .table-wrap, .list-wrap { overflow: auto; flex: 1 1 auto; min-height: 0; }
    .ladder-list { padding-left: 20px; margin: 0; }
    .ladder-row { margin: 6px 0; display:flex; align-items:center; gap:10px }
    .medal { width:28px; height:28px; display:inline-block }
    .ladder-info { flex: 1 }
    pre.csv-preview { white-space: pre-wrap; background:#f6f6f6; padding:8px; border-radius:4px }
    table.raw-table { border-collapse: collapse; width: 100%; }
    table.raw-table th, table.raw-table td { border: 1px solid #ddd; padding: 6px 8px; }
    table.raw-table th { text-align: left; }
    table.raw-table th.timestamp-col { width: 160px; }
    /* Narrow columns used for gate counts */
    .col-narrow { white-space: nowrap; }
    .col-d { min-width: 64px; max-width: 100px; text-align: right; }
    .col-nand { min-width: 64px; max-width: 100px; text-align: right; }
  </style>
</head>
<body>
  <h1>CSCML25 Circuit Challenges Ladderboard</h1>
  <div id="status">Loading...</div>
  <div id="content"></div>

  <script>
    function escapeHtml(value) {
      if (value === null || value === undefined) return '';
      return String(value).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }
    // Robust CSV parser (RFC4180-ish) that supports quoted fields with newlines and escaped quotes
    function parseCsvRows(csvText) {
      const rows = [];
      let cur = '';
      let inQuotes = false;
      let field = '';
      const pushField = (r) => { r.push(field); field = ''; };
      const pushRow = (r) => { rows.push(r.slice()); r.length = 0; };

      const row = [];
      for (let i = 0; i < csvText.length; i++) {
        const ch = csvText[i];
        const next = csvText[i+1];
        if (inQuotes) {
          if (ch === '"') {
            if (next === '"') {
              field += '"'; // escaped quote
              i++; // skip next
            } else {
              inQuotes = false; // end of quoted field
            }
          } else {
            field += ch;
          }
        } else {
          if (ch === '"') {
            inQuotes = true;
          } else if (ch === ',') {
            row.push(field);
            field = '';
          } else if (ch === '\r') {
            // ignore CR, handle on LF
          } else if (ch === '\n') {
            row.push(field);
            field = '';
            rows.push(row.slice());
            row.length = 0;
          } else {
            field += ch;
          }
        }
      }
      // push last field/row
      if (inQuotes) {
        // malformed CSV: unterminated quotes â€” but push as-is
      }
      if (field !== '' || row.length > 0) {
        row.push(field);
        rows.push(row.slice());
      }
      return rows;
    }

    function parseCsvToObjects(csvText) {
      const rows = parseCsvRows(csvText || '');
      if (!rows || rows.length === 0) return [];
      const headers = rows[0].map(h => (h || '').trim());
      const objs = [];
      for (let i = 1; i < rows.length; i++) {
        const cols = rows[i];
        const obj = {};
        for (let j = 0; j < headers.length; j++) {
          obj[headers[j]] = (cols[j] === undefined) ? '' : cols[j];
        }
        objs.push(obj);
      }
      return objs;
    }
    function medalSvg(type) {
      const colors = { gold: '#ffd700', silver: '#c0c0c0', bronze: '#cd7f32' };
      const color = colors[type] || '#999';
      return '<svg width="28" height="28" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><circle cx="12" cy="9" r="5" fill="'+color+'" stroke="#333" stroke-width="0.5" /><rect x="9" y="14" width="6" height="8" fill="'+color+'" /><path d="M6 4 L12 10 L18 4" stroke="#333" stroke-width="1" fill="none" /></svg>';
    }

    (async function(){
      try {
        const params = new URLSearchParams(window.location.search);
        const csvUrl = params.get('csv');
        const mode = (params.get('mode')||'grouped').toLowerCase();
        if (!csvUrl) throw new Error('csv query parameter required');
        document.getElementById('status').textContent = 'Fetching CSV...';
        const r = await fetch(csvUrl);
        if (!r.ok) throw new Error('Fetch failed: '+r.status+' '+r.statusText);
        const text = await r.text();
        const records = parseCsvToObjects(text||'');
        if (!records.length) {
          document.getElementById('status').textContent = 'No records found';
          document.getElementById('content').innerHTML = '<pre class="csv-preview">'+escapeHtml(text)+'</pre>';
          return;
        }
        document.getElementById('status').textContent = '';
        const norm = k => (k||'').replace(/[^a-zA-Z0-9_]/g,'').toLowerCase();
        const mapped = records.map(r=>{ const o={}; for(const k in r) o[norm(k)]=r[k]; return o; });
        if (mode === 'raw') {
          // Render one table per challenge (hide Circuit column). Use canonical challenge order when available.
          const content = document.getElementById('content');
          const headers = Object.keys(records[0]);
          const circuitIdx = headers.findIndex(h => /circuit/i.test(h));
          const challengeIdx = headers.findIndex(h => /challenge/i.test(h));

          // Decide visible header order: hide Challenge, put Submitter first (if present), then D gates, NAND gates, Email, Submission Time (timestamp), then others
          const headerLookup = {};
          headers.forEach(h => { headerLookup[h.toLowerCase().replace(/[^a-z0-9]/g,'')] = h; });
          const pickHeader = (re) => {
            for (const h of headers) if (re.test(h)) return h;
            return null;
          };
          const submitterHdr = pickHeader(/submitter|name/i);
          const dHdr = pickHeader(/d\s*gates|dgates|^d$/i);
          const nandHdr = pickHeader(/nand\s*gates|nandgates|^nand$/i);
          const tsHdr = pickHeader(/timestamp|time|date/i);

          const visible = [];
          if (submitterHdr) visible.push(submitterHdr);
          if (dHdr) visible.push(dHdr);
          if (nandHdr) visible.push(nandHdr);
          if (tsHdr) visible.push(tsHdr);
          // add remaining headers except circuit and challenge
          headers.forEach(h => {
            if (h === submitterHdr || h === dHdr || h === nandHdr || h === tsHdr) return;
            if (/circuit/i.test(h)) return;
            if (/challenge/i.test(h)) return; // hide challenge column
            visible.push(h);
          });

          // Group records by challenge header value
          const groups = {};
          records.forEach(rw => {
            const ch = (challengeIdx >= 0) ? (rw[headers[challengeIdx]] || 'unknown') : 'unknown';
            if (!groups[ch]) groups[ch] = [];
            groups[ch].push(rw);
          });

          // Try to get canonical challenge list (prefer stable ordering)
          async function fetchChallengesListLocal() {
            const candidates = ['../../challenges/challenges.json','../challenges/challenges.json','challenges/challenges.json'];
            for (const p of candidates) {
              try {
                const r = await fetch(p);
                if (!r.ok) continue;
                const arr = await r.json();
                if (Array.isArray(arr) && arr.length) return arr;
              } catch (e) {
                // ignore
              }
            }
            return null;
          }

          const canonical = await fetchChallengesListLocal();
          const order = (canonical && canonical.length) ? canonical : Object.keys(groups).sort();

          // Helper to set content height to fill viewport minus header/status
          function adjustContentHeight() {
            try {
              const contentEl = document.getElementById('content');
              if (!contentEl) return;
              const rect = contentEl.getBoundingClientRect();
              const bottomPadding = 16; // keep a small gap from bottom
              const newH = Math.max(100, window.innerHeight - rect.top - bottomPadding);
              contentEl.style.height = newH + 'px';
            } catch (e) {
              // ignore
            }
          }

          // Render a table for each challenge in order
          content.innerHTML = '';
          order.forEach(chName => {
            const rows = groups[chName] || [];
            const section = document.createElement('div');
            section.className = 'ladder-challenge-section';
            const h = document.createElement('h3'); h.textContent = chName; section.appendChild(h);
            if (rows.length === 0) {
              const empty = document.createElement('div'); empty.textContent = 'No submissions yet.'; empty.style.color = '#666'; section.appendChild(empty);
            } else {
              const tableWrap = document.createElement('div'); tableWrap.className = 'table-wrap';
              const table = document.createElement('table'); table.className = 'raw-table';
              const thead = document.createElement('thead'); const trh = document.createElement('tr');
              // Render headers in preferred visible order
              visible.forEach(hdr => {
                const th = document.createElement('th');
                // Rename timestamp header
                if (tsHdr && hdr === tsHdr) th.textContent = 'Submission Time';
                else th.textContent = hdr;
                // Add classes for styling narrow columns
                if (tsHdr && hdr === tsHdr) th.className = 'timestamp-col';
                if (dHdr && hdr === dHdr) th.classList.add('col-d', 'col-narrow');
                if (nandHdr && hdr === nandHdr) th.classList.add('col-nand', 'col-narrow');
                trh.appendChild(th);
              });
              thead.appendChild(trh); table.appendChild(thead);
              const tbody = document.createElement('tbody');
              rows.forEach(rw => {
                const tr = document.createElement('tr');
                // Render columns in visible order
                visible.forEach(hdr => {
                  const td = document.createElement('td');
                  td.textContent = rw[hdr] || '';
                  // mirror header classes for narrow columns
                  if (dHdr && hdr === dHdr) td.classList.add('col-d', 'col-narrow');
                  if (nandHdr && hdr === nandHdr) td.classList.add('col-nand', 'col-narrow');
                  if (tsHdr && hdr === tsHdr) td.classList.add('timestamp-col');
                  tr.appendChild(td);
                });
                tbody.appendChild(tr);
              });
              table.appendChild(tbody);
              tableWrap.appendChild(table);
              section.appendChild(tableWrap);
            }
            content.appendChild(section);
          });
          // ensure content fills viewport
          adjustContentHeight();
          window.addEventListener('resize', adjustContentHeight);
          return;
        }
        // grouped mode â€” build groups per challenge
        const groups = {};
        mapped.forEach(rw=>{
         const ch = rw['challenge'] || 'unknown';
         if (!groups[ch]) groups[ch]=[];
         // normalized header names remove spaces, e.g. 'D gates' -> 'dgates'
         const dStr = (rw['dgates'] || rw['d'] || '');
         const nStr = (rw['nandgates'] || rw['nand'] || '');
         const d = parseInt(String(dStr).replace(/[^0-9]/g,''),10) || 0;
         const nand = parseInt(String(nStr).replace(/[^0-9]/g,''),10) || 0;
         const ts = new Date(rw['timestamp']||rw['time']||rw['date']||'');
         groups[ch].push({ submitter: rw['submitter']||rw['name']||'', email: rw['email']||'', d, nand, ts });
        });

        const content = document.getElementById('content');

        // Create an array of group entries with their sorted lists and best-key for ordering sections
        const groupEntries = Object.keys(groups).map(ch => {
          const arr = groups[ch];
          // sort lexicographically by D, then NAND, then Timestamp (ISO string)
          arr.sort((a,b) => {
            const da = String(a.d || ''), db = String(b.d || '');
            if (da < db) return -1; if (da > db) return 1;
            const na = String(a.nand || ''), nb = String(b.nand || '');
            if (na < nb) return -1; if (na > nb) return 1;
            const ta = String(a.tsIso || ''), tb = String(b.tsIso || '');
            if (ta < tb) return -1; if (ta > tb) return 1;
            return 0;
          });
          const best = arr.length ? arr[0] : null;
          const bestKey = best ? [String(best.d), String(best.nand), String(best.tsIso || '')] : [''];
          return { ch, arr, bestKey };
        });

        // Sort the challenge sections by their best entry's key lexicographically
        groupEntries.sort((A,B) => {
          const ka = A.bestKey; const kb = B.bestKey;
          for (let i = 0; i < Math.max(ka.length, kb.length); i++) {
            const aVal = String(ka[i] || '');
            const bVal = String(kb[i] || '');
            if (aVal < bVal) return -1;
            if (aVal > bVal) return 1;
          }
          return A.ch.localeCompare(B.ch);
        });

        // Render each group's section. Prefer canonical challenge order from challenges/challenges.json
        async function fetchChallengesList() {
          const candidates = ['../../challenges/challenges.json','../challenges/challenges.json','challenges/challenges.json'];
          for (const p of candidates) {
            try {
              const r = await fetch(p);
              if (!r.ok) continue;
              const arr = await r.json();
              if (Array.isArray(arr) && arr.length) return arr;
            } catch (e) {
              // ignore and try next
            }
          }
          return null;
        }

        const canonicalChallenges = await fetchChallengesList();

        if (canonicalChallenges && canonicalChallenges.length) {
          // Render in canonical order; include empty sections when no submissions exist
          canonicalChallenges.forEach(chName => {
            const found = groupEntries.find(g => g.ch === chName);
            const arr = found ? found.arr : [];
            const section = document.createElement('div');
            section.className = 'ladder-challenge-section';
            const h = document.createElement('h3'); h.textContent = chName; section.appendChild(h);
            const listWrap = document.createElement('div'); listWrap.className='list-wrap';
            const ol = document.createElement('ol'); ol.className='ladder-list';
            if (arr.length === 0) {
              const empty = document.createElement('div'); empty.textContent = 'No submissions yet.'; empty.style.color='#666'; section.appendChild(empty);
            } else {
              arr.forEach((row, idx)=>{
                const li = document.createElement('li'); li.className='ladder-row';
                const medal = idx===0?medalSvg('gold'):(idx===1?medalSvg('silver'):(idx===2?medalSvg('bronze'):''));
                const medalSpan = document.createElement('span'); medalSpan.className='medal'; medalSpan.innerHTML = medal;
                const info = document.createElement('span'); info.className='ladder-info'; info.innerHTML = '<strong>'+escapeHtml(row.submitter||'(anonymous)')+'</strong> â€” D: '+escapeHtml(row.d||'')+', NAND: '+escapeHtml(row.nand||'')+' â€” '+escapeHtml(row.tsIso||'');
                li.appendChild(medalSpan); li.appendChild(info); ol.appendChild(li);
              });
            }
            listWrap.appendChild(ol);
            section.appendChild(listWrap);
            content.appendChild(section);
          });
          // ensure content fills viewport
          adjustContentHeight();
          window.addEventListener('resize', adjustContentHeight);
        } else {
          // Fallback: render whatever groups we discovered from the CSV
          groupEntries.forEach(({ch, arr}) => {
            const section = document.createElement('div');
            section.className = 'ladder-challenge-section';
            const h = document.createElement('h3'); h.textContent = ch; section.appendChild(h);
            const listWrap = document.createElement('div'); listWrap.className='list-wrap';
            const ol = document.createElement('ol'); ol.className='ladder-list';
            arr.forEach((row, idx)=>{
              const li = document.createElement('li'); li.className='ladder-row';
              const medal = idx===0?medalSvg('gold'):(idx===1?medalSvg('silver'):(idx===2?medalSvg('bronze'):''));
              const medalSpan = document.createElement('span'); medalSpan.className='medal'; medalSpan.innerHTML = medal;
              const info = document.createElement('span'); info.className='ladder-info'; info.innerHTML = '<strong>'+escapeHtml(row.submitter||'(anonymous)')+'</strong> â€” D: '+escapeHtml(row.d||'')+', NAND: '+escapeHtml(row.nand||'')+' â€” '+escapeHtml(row.email||'')+' â€” '+escapeHtml(row.tsIso||'');
              li.appendChild(medalSpan); li.appendChild(info); ol.appendChild(li);
            });
            listWrap.appendChild(ol);
            section.appendChild(listWrap);
            content.appendChild(section);
          });
          // ensure content fills viewport
          adjustContentHeight();
          window.addEventListener('resize', adjustContentHeight);
        }
      } catch (err) {
        document.getElementById('status').textContent = 'Error: '+(err && err.message?err.message:err);
        console.error(err);
      }
    })();
  </script>
</body>
</html>